use crate::schema::ir::frozen::unit::FrozenUnit;
use crate::schema::ir::compiler::interpreted::kind_search::{KindValue, Primitive};

pub fn generate_rust(units: &Vec<FrozenUnit>) -> String {
    let mut output = String::new();
    
    // Add standard header
    output.push_str("// Generated by Comline\n");
    output.push_str("use serde::{Serialize, Deserialize};\n\n");

    for unit in units {
        match unit {
            FrozenUnit::Struct { name, fields, .. } => {
                output.push_str(&generate_struct(name, fields));
            }
            FrozenUnit::Enum { name, variants, .. } => {
                output.push_str(&generate_enum(name, variants));
            }
            FrozenUnit::Protocol { name, functions, .. } => {
                output.push_str(&generate_protocol(name, functions));
            }
            _ => {}
        }
    }
    
    output
}

fn generate_struct(name: &str, fields: &Vec<FrozenUnit>) -> String {
    let mut s = format!("#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {} {{\n", name);
    
    for field in fields {
        if let FrozenUnit::Field { name, kind_value, .. } = field {
            let type_name = map_kind_to_rust_type(kind_value);
            s.push_str(&format!("    pub {}: {},\n", name, type_name));
        }
    }
    
    s.push_str("}\n\n");
    s
}

fn generate_protocol(name: &str, functions: &Vec<FrozenUnit>) -> String {
    let mut s = format!("pub trait {} {{\n", name);
    
    for func in functions {
        if let FrozenUnit::Function { name, arguments, _return, .. } = func {
            let args_str = arguments.iter().map(|arg| {
                 format!("{}: {}", arg.name, map_kind_to_rust_type(&arg.kind))
            }).collect::<Vec<_>>().join(", ");
            
            let ret_str = if let Some(ret) = _return {
                format!(" -> {}", map_kind_to_rust_type(ret))
            } else {
                "".to_string()
            };
            
            s.push_str(&format!("    fn {}({}){};\n", name, args_str, ret_str));
        }
    }
    
    s.push_str("}\n\n");
    s
}

fn generate_enum(name: &str, variants: &Vec<FrozenUnit>) -> String {
    let mut s = format!("#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum {} {{\n", name);
    
    for variant in variants {
        if let FrozenUnit::EnumVariant(kv) = variant {
            // Extract name from KindValue. 
            // Usually EnumVariant(String, Option<Box>) or Primitive?
            // incremental.rs maps it to EnumVariant(name, None).
            let variant_name = match kv {
                KindValue::EnumVariant(n, _) => n.clone(),
                KindValue::Namespaced(n, _) => n.clone(), // Fallback
                _ => "Unknown".to_string(),
            };
             s.push_str(&format!("    {},\n", variant_name));
        }
    }
    
    s.push_str("}\n\n");
    s
}

fn map_kind_to_rust_type(kind: &KindValue) -> String {
    match kind {
        KindValue::Primitive(p) => {
             map_str_type(p.name())
        }
        KindValue::Namespaced(name, _) => {
             map_str_type(name)
        }
        KindValue::EnumVariant(name, _) => name.clone(),
        _ => "/* unknown_kind */".to_string()
    }
}

fn map_str_type(s: &str) -> String {
    if s.ends_with("[]") {
        let inner = &s[..s.len()-2];
        return format!("Vec<{}>", map_str_type(inner));
    }
    match s {
        "string" | "str" => "String".to_string(),
        "bool" => "bool".to_string(),
        "float" => "f64".to_string(),
        "int" => "i32".to_string(), // default to i32 for generic int
        "u8" => "u8".to_string(),
        "u16" => "u16".to_string(),
        "u32" => "u32".to_string(),
        "u64" => "u64".to_string(),
        "i8" => "i8".to_string(),
        "i16" => "i16".to_string(),
        "i32" => "i32".to_string(),
        "i64" => "i64".to_string(),
        other => other.to_string(),
    }
}
